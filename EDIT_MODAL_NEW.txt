// This is the new EditModal component with all required changes
// Copy this to replace the existing EditModal in MockupCanvas.tsx

function EditModal({ mockupImage, designImage, transform, onTransformChange, onClose }: EditModalProps) {
  const canvasRef = useRef<HTMLCanvasElement>(null)
  const [isDragging, setIsDragging] = useState(false)
  const [dragStart, setDragStart] = useState({ x: 0, y: 0 })
  const [dragInitial, setDragInitial] = useState({ x: 0, y: 0 })

  // Local state: clone transform on open, only commit on Apply
  const [localTransform, setLocalTransform] = useState<Transform>(() => ({ ...transform }))
  const initialTransform = useRef<Transform>({ ...transform })

  const [lastPinchDistance, setLastPinchDistance] = useState<number | null>(null)
  const [pinchInitialScale, setPinchInitialScale] = useState(1)
  const [scaleAnchor, setScaleAnchor] = useState<{ x: number; y: number } | null>(null)
  const [isDraggingHandle, setIsDraggingHandle] = useState<'left' | 'right' | 'top' | 'bottom' | null>(null)
  const [handleDragStart, setHandleDragStart] = useState({ x: 0, y: 0 })
  const [handleInitialScale, setHandleInitialScale] = useState({ scaleX: 1, scaleY: 1 })

  // Helper function to snap rotation to cardinal angles
  const snapRotation = (rotation: number): number => {
    const snapAngles = [0, 90, 180, 270, 360]
    const snapThreshold = 2

    for (const angle of snapAngles) {
      if (Math.abs(rotation - angle) <= snapThreshold) {
        return angle % 360
      }
    }
    return rotation
  }

  // Block body scroll when modal is open
  useEffect(() => {
    document.body.style.overflow = 'hidden'
    return () => {
      document.body.style.overflow = ''
    }
  }, [])

  // Handle Apply button
  const handleApply = () => {
    onTransformChange(localTransform)
    onClose()
  }

  // Handle Close button (discard changes)
  const handleClose = () => {
    onClose()
  }

  // Handle keyboard shortcuts
  useEffect(() => {
    const handleKeyDown = (e: KeyboardEvent) => {
      // Cmd/Ctrl+Enter = Apply
      if ((e.metaKey || e.ctrlKey) && e.key === 'Enter') {
        e.preventDefault()
        handleApply()
        return
      }

      // Escape = Close (discard)
      if (e.key === 'Escape') {
        e.preventDefault()
        handleClose()
        return
      }

      // Arrow key nudging
      if (['ArrowUp', 'ArrowDown', 'ArrowLeft', 'ArrowRight'].includes(e.key)) {
        e.preventDefault()
        if (!mockupImage) return

        const nudgeAmount = e.shiftKey ? 10 : 1
        let dx = 0
        let dy = 0

        switch (e.key) {
          case 'ArrowLeft': dx = -nudgeAmount; break
          case 'ArrowRight': dx = nudgeAmount; break
          case 'ArrowUp': dy = -nudgeAmount; break
          case 'ArrowDown': dy = nudgeAmount; break
        }

        setLocalTransform(prev => ({ ...prev, x: prev.x + dx, y: prev.y + dy }))
      }
    }

    window.addEventListener('keydown', handleKeyDown)
    return () => window.removeEventListener('keydown', handleKeyDown)
  }, [mockupImage, localTransform])

  // Draw preview
  useEffect(() => {
    const canvas = canvasRef.current
    if (!canvas || !mockupImage) return

    const ctx = canvas.getContext('2d', { alpha: false })
    if (!ctx) return

    // Use 80% of viewport for canvas size
    const maxWidth = window.innerWidth * 0.8
    const maxHeight = window.innerHeight * 0.8
    const aspectRatio = mockupImage.width / mockupImage.height

    let width = maxWidth
    let height = maxWidth / aspectRatio

    if (height > maxHeight) {
      height = maxHeight
      width = maxHeight * aspectRatio
    }

    canvas.width = width
    canvas.height = height

    // Scale factors
    const scaleX = width / mockupImage.width
    const scaleY = height / mockupImage.height

    // Clear and draw mockup
    ctx.clearRect(0, 0, width, height)
    ctx.drawImage(mockupImage, 0, 0, width, height)

    // Draw design if available
    if (designImage) {
      ctx.save()
      ctx.globalAlpha = localTransform.opacity / 100
      ctx.translate(localTransform.x * scaleX, localTransform.y * scaleY)
      ctx.rotate((localTransform.rotation * Math.PI) / 180)
      ctx.scale(localTransform.scale * localTransform.scaleX * scaleX, localTransform.scale * localTransform.scaleY * scaleY)
      ctx.drawImage(
        designImage,
        -designImage.width / 2,
        -designImage.height / 2
      )
      ctx.restore()
    }
  }, [mockupImage, designImage, localTransform])

  const handleMouseDown = (e: React.MouseEvent<HTMLCanvasElement>) => {
    if (!mockupImage || !designImage) return

    const canvas = canvasRef.current
    if (!canvas) return

    const rect = canvas.getBoundingClientRect()
    const scaleX = canvas.width / rect.width
    const scaleY = canvas.height / rect.height
    const mouseX = (e.clientX - rect.left) * scaleX
    const mouseY = (e.clientY - rect.top) * scaleY

    setIsDragging(true)
    setDragStart({ x: mouseX, y: mouseY })
    setDragInitial({ x: localTransform.x, y: localTransform.y })

    if (e.altKey) {
      setScaleAnchor({ x: mouseX, y: mouseY })
    }

    e.preventDefault()
  }

  const handleMouseMove = (e: React.MouseEvent<HTMLCanvasElement>) => {
    if (!isDragging || !mockupImage) return

    const canvas = canvasRef.current
    if (!canvas) return

    const rect = canvas.getBoundingClientRect()
    const scaleX = canvas.width / rect.width
    const scaleY = canvas.height / rect.height
    const mouseX = (e.clientX - rect.left) * scaleX
    const mouseY = (e.clientY - rect.top) * scaleY

    let dx = mouseX - dragStart.x
    let dy = mouseY - dragStart.y

    // Shift to lock axis
    if (e.shiftKey) {
      if (Math.abs(dx) > Math.abs(dy)) {
        dy = 0
      } else {
        dx = 0
      }
    }

    const mockupScaleX = mockupImage.width / canvas.width
    const mockupScaleY = mockupImage.height / canvas.height

    const newX = dragInitial.x + (dx * mockupScaleX)
    const newY = dragInitial.y + (dy * mockupScaleY)

    setLocalTransform(prev => ({ ...prev, x: newX, y: newY }))
  }

  const handleMouseUp = () => {
    setIsDragging(false)
    setScaleAnchor(null)
  }

  const handleWheel = (e: React.WheelEvent<HTMLCanvasElement>) => {
    e.preventDefault()
    if (!mockupImage) return

    const canvas = canvasRef.current
    if (!canvas) return

    const delta = -e.deltaY * 0.001
    let newScale = Math.max(0.05, Math.min(3, localTransform.scale + delta))
    let newX = localTransform.x
    let newY = localTransform.y

    // Alt key: scale from center
    if (e.altKey || scaleAnchor) {
      const rect = canvas.getBoundingClientRect()
      const scaleX = canvas.width / rect.width
      const scaleY = canvas.height / rect.height

      const anchorX = scaleAnchor ? scaleAnchor.x : (e.clientX - rect.left) * scaleX
      const anchorY = scaleAnchor ? scaleAnchor.y : (e.clientY - rect.top) * scaleY

      const mockupScaleX = mockupImage.width / canvas.width
      const mockupScaleY = mockupImage.height / canvas.height
      const mockupAnchorX = anchorX * mockupScaleX
      const mockupAnchorY = anchorY * mockupScaleY

      const scaleDiff = newScale - localTransform.scale
      const offsetX = (mockupAnchorX - localTransform.x) * (scaleDiff / localTransform.scale)
      const offsetY = (mockupAnchorY - localTransform.y) * (scaleDiff / localTransform.scale)

      newX = localTransform.x - offsetX
      newY = localTransform.y - offsetY
    }

    setLocalTransform(prev => ({ ...prev, scale: newScale, scaleX: 1.0, scaleY: 1.0, x: newX, y: newY }))
  }

  // Touch handlers
  const getTouchDistance = (touches: React.TouchList) => {
    if (touches.length < 2) return null
    const dx = touches[0].clientX - touches[1].clientX
    const dy = touches[0].clientY - touches[1].clientY
    return Math.sqrt(dx * dx + dy * dy)
  }

  const handleTouchStart = (e: React.TouchEvent<HTMLCanvasElement>) => {
    if (e.touches.length === 2) {
      const distance = getTouchDistance(e.touches)
      if (distance) {
        setLastPinchDistance(distance)
        setPinchInitialScale(localTransform.scale)
      }
      e.preventDefault()
    } else if (e.touches.length === 1) {
      if (!mockupImage || !designImage) return

      const canvas = canvasRef.current
      if (!canvas) return

      const rect = canvas.getBoundingClientRect()
      const scaleX = canvas.width / rect.width
      const scaleY = canvas.height / rect.height
      const touchX = (e.touches[0].clientX - rect.left) * scaleX
      const touchY = (e.touches[0].clientY - rect.top) * scaleY

      setIsDragging(true)
      setDragStart({ x: touchX, y: touchY })
      setDragInitial({ x: localTransform.x, y: localTransform.y })
    }
  }

  const handleTouchMove = (e: React.TouchEvent<HTMLCanvasElement>) => {
    if (e.touches.length === 2) {
      const distance = getTouchDistance(e.touches)
      if (distance && lastPinchDistance) {
        const scaleFactor = distance / lastPinchDistance
        const newScale = Math.max(0.05, Math.min(3, pinchInitialScale * scaleFactor))
        setLocalTransform(prev => ({ ...prev, scale: newScale }))
      }
      e.preventDefault()
    } else if (e.touches.length === 1 && isDragging) {
      if (!mockupImage) return

      const canvas = canvasRef.current
      if (!canvas) return

      const rect = canvas.getBoundingClientRect()
      const scaleX = canvas.width / rect.width
      const scaleY = canvas.height / rect.height
      const touchX = (e.touches[0].clientX - rect.left) * scaleX
      const touchY = (e.touches[0].clientY - rect.top) * scaleY

      const dx = touchX - dragStart.x
      const dy = touchY - dragStart.y

      const mockupScaleX = mockupImage.width / canvas.width
      const mockupScaleY = mockupImage.height / canvas.height

      const newX = dragInitial.x + (dx * mockupScaleX)
      const newY = dragInitial.y + (dy * mockupScaleY)

      setLocalTransform(prev => ({ ...prev, x: newX, y: newY }))
      e.preventDefault()
    }
  }

  const handleTouchEnd = () => {
    setIsDragging(false)
    setLastPinchDistance(null)
  }

  // Handle stretch handles
  const handleStretchMouseDown = (e: React.MouseEvent, handle: 'left' | 'right' | 'top' | 'bottom') => {
    e.stopPropagation()
    e.preventDefault()
    setIsDraggingHandle(handle)
    setHandleDragStart({ x: e.clientX, y: e.clientY })
    setHandleInitialScale({ scaleX: localTransform.scaleX, scaleY: localTransform.scaleY })
  }

  useEffect(() => {
    if (!isDraggingHandle) return

    const handleGlobalMouseMove = (e: MouseEvent) => {
      if (!isDraggingHandle || !designImage) return

      const dx = e.clientX - handleDragStart.x
      const dy = e.clientY - handleDragStart.y
      const sensitivity = 0.003

      let newScaleX = handleInitialScale.scaleX
      let newScaleY = handleInitialScale.scaleY

      const horizontalOnly = e.ctrlKey || e.metaKey
      const verticalOnly = e.shiftKey

      if (isDraggingHandle === 'left' || isDraggingHandle === 'right') {
        const direction = isDraggingHandle === 'right' ? 1 : -1
        if (!verticalOnly) {
          newScaleX = Math.max(0.1, Math.min(3, handleInitialScale.scaleX + dx * direction * sensitivity))
        }
      } else {
        const direction = isDraggingHandle === 'bottom' ? 1 : -1
        if (!horizontalOnly) {
          newScaleY = Math.max(0.1, Math.min(3, handleInitialScale.scaleY + dy * direction * sensitivity))
        }
      }

      setLocalTransform(prev => ({ ...prev, scaleX: newScaleX, scaleY: newScaleY }))
    }

    const handleGlobalMouseUp = () => {
      setIsDraggingHandle(null)
    }

    window.addEventListener('mousemove', handleGlobalMouseMove)
    window.addEventListener('mouseup', handleGlobalMouseUp)

    return () => {
      window.removeEventListener('mousemove', handleGlobalMouseMove)
      window.removeEventListener('mouseup', handleGlobalMouseUp)
    }
  }, [isDraggingHandle, handleDragStart, handleInitialScale, designImage])

  return createPortal(
    <div
      className="fixed inset-0 bg-black bg-opacity-90 flex items-center justify-center p-4"
      style={{ zIndex: 9999 }}
      onClick={handleClose}
    >
      <div
        className="relative max-w-full max-h-full flex flex-col items-center"
        onClick={(e) => e.stopPropagation()}
      >
        {/* Header with Apply and Close buttons */}
        <div className="mb-4 flex items-center gap-4 bg-gray-800 px-6 py-3 rounded-lg w-full">
          <div className="text-sm text-gray-300 flex-1">
            X: {localTransform.x.toFixed(0)} • Y: {localTransform.y.toFixed(0)} • Scale: {localTransform.scale.toFixed(2)}x •
            Rotation: {localTransform.rotation}°
          </div>
          <button
            onClick={handleApply}
            className="px-4 py-2 text-sm bg-green-600 hover:bg-green-700 text-white font-semibold rounded transition"
            title="Apply changes and close (Cmd/Ctrl+Enter)"
          >
            Apply
          </button>
          <button
            onClick={handleClose}
            className="px-4 py-2 text-sm bg-gray-600 hover:bg-gray-700 text-white rounded transition"
            title="Close without saving (Esc)"
          >
            Close
          </button>
        </div>

        {/* Canvas with Stretch Handles */}
        <div className="relative bg-gray-900 rounded-lg overflow-visible shadow-2xl" style={{ touchAction: 'none' }}>
          <canvas
            ref={canvasRef}
            className="max-w-full max-h-full cursor-move"
            style={{ cursor: isDragging ? 'grabbing' : 'grab' }}
            onMouseDown={handleMouseDown}
            onMouseMove={handleMouseMove}
            onMouseUp={handleMouseUp}
            onMouseLeave={handleMouseUp}
            onWheel={handleWheel}
            onTouchStart={handleTouchStart}
            onTouchMove={handleTouchMove}
            onTouchEnd={handleTouchEnd}
          />

          {/* Stretch Handles Overlay */}
          {designImage && (
            <>
              <div
                className="absolute w-3 h-12 bg-blue-500 hover:bg-blue-400 rounded cursor-ew-resize"
                style={{ left: '-6px', top: '50%', transform: 'translateY(-50%)' }}
                onMouseDown={(e) => handleStretchMouseDown(e, 'left')}
                title="Drag to stretch horizontally"
              />
              <div
                className="absolute w-3 h-12 bg-blue-500 hover:bg-blue-400 rounded cursor-ew-resize"
                style={{ right: '-6px', top: '50%', transform: 'translateY(-50%)' }}
                onMouseDown={(e) => handleStretchMouseDown(e, 'right')}
                title="Drag to stretch horizontally"
              />
              <div
                className="absolute w-12 h-3 bg-green-500 hover:bg-green-400 rounded cursor-ns-resize"
                style={{ top: '-6px', left: '50%', transform: 'translateX(-50%)' }}
                onMouseDown={(e) => handleStretchMouseDown(e, 'top')}
                title="Drag to stretch vertically"
              />
              <div
                className="absolute w-12 h-3 bg-green-500 hover:bg-green-400 rounded cursor-ns-resize"
                style={{ bottom: '-6px', left: '50%', transform: 'translateX(-50%)' }}
                onMouseDown={(e) => handleStretchMouseDown(e, 'bottom')}
                title="Drag to stretch vertically"
              />
            </>
          )}
        </div>

        {/* Rotation Control */}
        <div className="mt-4 bg-gray-800 rounded-lg p-4 w-full max-w-md">
          <div className="mb-3">
            <div className="flex justify-between items-center mb-2">
              <label className="text-sm font-medium">Rotation: {localTransform.rotation}°</label>
              <button
                onClick={() => setLocalTransform(prev => ({ ...prev, rotation: 0 }))}
                className="px-2 py-1 text-xs bg-gray-600 hover:bg-gray-500 rounded transition"
              >
                Reset to 0°
              </button>
            </div>
            <div className="flex gap-2 items-center">
              <input
                type="range"
                min="0"
                max="360"
                step="1"
                value={localTransform.rotation}
                onChange={(e) => {
                  const rawValue = parseInt(e.target.value)
                  const snappedValue = snapRotation(rawValue)
                  setLocalTransform(prev => ({ ...prev, rotation: snappedValue }))
                }}
                className="flex-1"
              />
              <input
                type="number"
                min="0"
                max="360"
                value={localTransform.rotation}
                onChange={(e) => {
                  const rawValue = parseInt(e.target.value) || 0
                  const clampedValue = Math.max(0, Math.min(360, rawValue))
                  const snappedValue = snapRotation(clampedValue)
                  setLocalTransform(prev => ({ ...prev, rotation: snappedValue }))
                }}
                className="w-16 px-2 py-1 text-sm bg-gray-700 border border-gray-600 rounded"
              />
            </div>
            <p className="text-xs text-gray-400 mt-1">
              Snaps at 0°, 90°, 180°, 270° (±2°)
            </p>
          </div>
        </div>

        {/* Instructions */}
        <p className="mt-4 text-xs text-gray-400 text-center max-w-md">
          Drag to move • Scroll to scale • Arrows = nudge • Shift = lock axis
        </p>
        <p className="text-xs text-gray-400 text-center max-w-md">
          <kbd className="bg-gray-700 px-1 rounded">Cmd/Ctrl+Enter</kbd> = Apply • <kbd className="bg-gray-700 px-1 rounded">Esc</kbd> = Close
        </p>
      </div>
    </div>,
    document.body
  )
}
